# 쿼리 튜닝 시작하기
---

0. 목차
1. 쿼리 튜닝이란
    1. 소개
    2. 방법
    3. 전제 조건 및 다루는 항목
2. 쿼리 성능 테스트 및 실행계획
    1. 성능 테스트를 위한 고려사항
3. index
    1. index 란?
    2. index 활용 시 고려사항
    3. index 기본
4. 연산자
5. SELECT
    1. WHERE
    2. GROUP BY, ORDER BY
    3. JOIN
    4. COUNT()
    5. 그 외
6. 기타 고려사항
7. 참고


======================================================================

## 1. 쿼리 튜닝이란

### 1. 소개
>쿼리가 실행될 때 일어나는 일련의 과정을 확인하고, 최적화하여 쿼리의 실행속도를 높이는 것.
>

- 슬로우 쿼리 로그 확인
  - 쿼리 수행 시간,
  - 쿼리가 수행되기까지의 시간
  - 테이블 독점 시간 등 
- 실행계획을 통해 , 쿼리가 어떻게 실행될 지 알아볼 수 있음.
- 보통 SELECT 쿼리 대상
    - INSERT와 UPDATE같은 작업은 거의 레코드 단위로 발생하므로 성능상 문제가 되는 경우가 많지 않음
- 약 1~2백만건 또는 그 이하의 레코드를 갖는 테이블에 대해서 너무 많은 시간을 쓰지 않아도 됨.


### 2. 방법

실행 계획을 통해 쿼리 수행 계획을 확인.

1. 인덱스 사용
2. 조인,서브쿼리 등의 적절한 활용
3. 병목 현상 개선 등 ... 

### 3. 환경 및 다루는 항목

MySQL 8.0을 기준으로 소개
DDL 보단, DML - 특히 SELECT - 를 중심으로 소개

기초적인 내용을 주로 다룸

- 실행 계획 보는 방법
- index 활용하는 기본적인 방법
- 연산자 사용 시 주의점
- 조인, 서브쿼리 시 주의점

## 2. 쿼리 성능 테스트 및 실행 계획

### 1. 성능 테스트를 위한 고려사항

<br> 쿼리를 직접 실행해보면서 성능 체크 시, 여러 영향요소가 있음을 고려해야 함.

    - 운영체제의 캐시 
        - DB 서버는 운영체제의 파일 시스템 관련 기능(시스템 풀)을 이용해 데이터 파일을 읽어옴. 일반적으로 한번 읽은 데이터는 OS가 관리하는 별도의 캐시 영역에 보관해두었다가, 디스크를 읽지않고 캐시의 내용을 DB 서버로 반환함.
        - OS가 관리하는 영역의 캐시이기 때문에, DB 서버와 같은 응용프로그램이 종료되어도 남아있을 수 있음.(캐시 삭제 명령어 사용)

    - DB 서버의 버퍼 풀
        - 버퍼 풀이란 데이터에 액세스할 때 테이블 및 인덱스 데이터를 캐시하는 메인 메모리 영역.
        - 데이터를 메모리에서 직접 액세스하기 때문에 디스크에서 긁어오는 것 보다 빠름 
        - DB 서버에서도 데이터 파일의 내용을 페이지(또는 블록)단위로 캐시함 
    - DB 서버가 기동 중인 장비에 웹서버나, 다른 배치용 프로그램이 실행중인 환경

    - 쿼리를 실행하는 클라이언트 프로그램, 네트워크 영향 요소

    - HW 성능

    - 워밍업 상태(캐시나 버퍼가 필요한 데이터로 준비된 상태) or 콜드 상태(캐시나 버퍼가 초기화 된 상태)
        - 어느정도 사용량이 있는 서비스라면, 대부분 워밍업 상태에서 실행되기 때문에 주로 워밍업 상태를 가정함
        - 캐시로 저장되는 양은 제한적이므로 플러시 작업과 캐시 작업이 반복해서 일어날 수 있음. -> 테스트하려는 쿼리를 번갈아가며 약 6~7번 정도 실행한 뒤, 처음 1~2번의 
        결과는 버리고 나머지 결과의 평균 값을 기준으로 비교하는 것이 좋음.

    - 실제 애플리케이션 상에서 실행되는 쿼리는 동시에 많은 쿼리가 실행 중인 상태일 수 있으며, 각 쿼리가 자원을 점유하기 위한 경합들이 발생할 수 있으므로 항상 테스트보다는 느린 처리성능을 보일 수 있음.

### 2. 쿼리 실행 계획
- explain 명령어 사용
- 워크벤치, 디비버 같은 툴에서 실행계획 시각화

```sql

explain
select * 
from world.country c 
left join world.city c2
    on c.Code = c2.CountryCode 
        and c2.Population > 1000000
where c.Population/5 > 1000000



#출력 결과
id  select_type table   type  possible_keys key     key_len ref        rows filtered    Extra  
1	SIMPLE	    c		ALL		null		null    null	            239	100.0	Using where
1	SIMPLE	    c2		ref	CountryCode	CountryCode	12	world.c.Code	17	100.0	Using where

```

- select_type
    - SIMPLE : 단순한 SELECT 문
    - PRIMARY : 서브쿼리를 감싸는 외부 쿼리, UNION이 포함될 경우 첫번째 SELECT 문
    - SUBQUERY : 독립적으로 수행되는 서브쿼리(SELECT, WHERE 절에 추가된 서브쿼리)
    - DERIVED : FROM 절에 작성된 서브쿼리UNION : UNION, UNION ALL로 합쳐진 SELECT 문
    - DEPENDENT SUBQUERY : 서브쿼리가 바깥쪽 SELECT 쿼리에 정의된 칼럼을 사용 하는 경우
    - DEPENDENT UNION : 외부에 정의된 칼럼을 UNION으로 결합된 쿼리에서 사용하는 경우
    - MATERIALZED : IN 절 구문의 서브쿼리를 임시 테이블로 생성한 뒤 조인을 수행UNCACHEABLE SUBQUERY : RAND(), UUID() 등 조회마다 결과가 달라지는 경우

- type
    - system : 테이블에 데이터가 없거나 한 개만 있는 경우
    - const : 조회되는 데이터가 단 1건일 때
    - eq_ref : 조인이 수행될 때 드리븐 테이블의 데이터에 PK 혹은 고유 인덱스로 단 1건의 데이터를 조회할 때
    - ref : eq_ref와 같으나 데이터가 2건 이상일 경우
    - index : 인덱스 풀 스캔
    - range : 인덱스 레인지 스캔
    - all : 테이블 풀 스캔

- key, key_len : 옵티마이저가 실제로 선택한 인덱스, 인덱스의 길이

- ref : key안의 인덱스와 비교하는 컬럼(상수)

- rows : SQL문을 수행하기 위해 접근하는 데이터의 모든 행 수


## 3. Index
### 1. Index란
- 책의 마지막에 있는 "찾아보기"가 인덱스에 비유된다면, 책의 내용은 데이터 파일에 해당됨.
- 책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유 됨.
- 컬럼의 값과 해당 레코드가 저장된 주소를 key-value로 삼아 인덱스를 만드는 것.
- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관. (sortedList와 마찬가지로, 항상 정렬된 상태임.)
### 2. Index 활용 시 고려사항
- 테이블 크기의 약 10%를 차지.
- 3~5개 정도를 설정하는 것이 가장 무난.
- 업데이트가 빈번하지 않은 컬럼을 설정하는 것이 좋음.
- 복합키를 설정할 경우 카디널리티가 높은 것부타 늦은 순으로 구성함
- 카티널리티가 높고, 선택도가 낮으며, 활용도가 높고, 중복 인덱스는 가급적 지양하는 기준으로 인덱스 설정
### 3. Index 기본
- 인덱스 연산(가공)하고나서 조건 비교 시, 인덱스를 타지 않음.
    - MD5()함수와 같이 해시값을 만들어서 비교해야 하는 경우라면, 미리 계산된 값을 저장하도록 MySQL의 가상 컬럼을 추가하고 <br>
      그 컬럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용.
- 데이터 타입 일치.

```sql

#code가 varchar 타입일 때 

##1 문자를 숫자와 비교할 때
explain
select * 
from user 
where code = 186800

1	SIMPLE	user		ALL	

##2 비교대상을 cast 했을 때
explain
select * from user where code = CAST(186800 AS CHAR);

#결과
1	SIMPLE	user		ref


```

## 4. 연산자
- AND, OR
    - OR 사용 시 탐색해야 하는 데이터의 범위가 넓어지므로 주의.
- LIKE
    - 와일드 카드(%)가 검색어의 뒤쪽에 있을 경우, 인덱스 레인지 스캔 가능하나 앞쪽에 있다면 불가
    - 인덱스의 Left-most 특성으로 인덱스 풀 스캔
- BETWEEN
    - 작거나 같다, 크거나 같다라는 두 개의 연산자를 하나로 합친 연산자
    - 쿼리에 따라서, BETWEEN은 선형으로 인덱스를 가져오므로 IN으로 동등 비교를 여러번 하는게 더 나음.
    - 인덱스 앞쪽에 있는 컬럼의 선택도가 떨어질때도 IN으로 변경하는 방법으로 쿼리의 성능 개선할 수 있음.
- IN
    - 상수 사용 IN (?,?,?)
        - 동등 비교와 동일하게 작동
        - mysql 8.0버전 이전에는 튜플 사용시 풀테이블 스캔을 했으나, 지금은 개선됨.
    - 서브쿼리 IN (SELECT... FROM...)
        - 8.0 이전까지만 해도 최적화가 불안정했으나 상당부분 개선됨.
    - NOT IN은 풀테이블스캔 사용함.


## 5. SELECT
### 1. WHERE
- WHERE절에 나열된 순서가 크게 중요하지 않음
    - 인덱스와 순서가 다르더라도,옵티마이저가 최적화 수행 가능
- OR 연산자가 사용되면 풀테이블 스캔을 대부분 사용하게 됨
    - 인덱스로 선택되지 않은 컬럼이 있을 경우, 풀테이블 스캔 한번으로 데이터를 조회하는 것이 더 빠르기때문
- IS NULL, ISNULL(컬럼)의 경우 인덱스 레인지 스캔이 가능하지만, 그 외는 풀스캔하는 형태로 처리됨.
- WHERE절에 조건이 여러개 나열된 경우,
    1. 인덱스를 사용하는 컬럼 먼저 조건실행됨.
    2. 실행 후 결과가 적게 나오는 거 부터 먼저 기재(연산되는 데이터의 범위 최소화)
### 2. GROUP BY, ORDER BY
- 다중 컬럼 인덱스를 기준으로, GROUP BY절에 명시된 컬럼은 인덱스 컬럼의 순서와 위치가 같아야 함.
### 3. JOIN
- 이너조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 옵티마이저가 조인 순서를 변경하며<br>
  수행할 수 있는 최적화의 기회를 빼앗아 버릴 수 있음. -> 가급적 이너조인 사용
- 아우터로 조인되는 테이블의 조건은 where절이 아니라 on절에 사용
  -> where절에 쓰이면 옵티마이저가 INNER로 바꿔버림
### 4. COUNT()
- 레코드의 건수를 반환
- COUNT 쿼리 실행 시, ORDER BY나 LEFT JOIN같이 레코드 건수를 가져오는 것 과는 무관한 작업을 포함하는 것 주의
- COUNT(null이 포함될 수 있는 컬럼 명시)의 경우 null이 아닌 컬럼의 수를 가져오므로 주의

### 5. 그 외
- 서브쿼리보다 CTE 사용 고려
- 윈도우 함수는 레코드를 많이 가공하므로 OLTP에선 주의

## 6. 기타 고려사항
- 읽기보다 쓰기가 많은 테이블에선, 인덱스의 개수를 최소화 하고 단조 증가, 감소되는 값으로 pk를 설정하는 것이 좋음.
- 한 번에 너무 많은 레코드를 변경, 삭제하는 작업은 서버에 과부하를 유발하거나 커넥션의 쿼리 처리를 방해할 수 있음.
- JOIN UPDATE 주의. 잠금 때문에 데드락 발생할 수 있음.


## 7. 참고자료
- https://nomadlee.com/mysql-explain-%ec%8b%a4%ed%96%89%ea%b3%84%ed%9a%8d-%ec%82%ac%ec%9a%a9%eb%b2%95-%eb%b0%8f-%eb%b6%84%ec%84%9d/
- Real Mysql 8.0
- https://sihyung92.oopy.io/database/mysql-query-plan