# Database Index (feat. MySQL)# 💡 Index 란?<img width="200" alt="스크린샷 2024-07-20 오후 11 49 22" src="https://github.com/user-attachments/assets/5d9baa64-0716-4d0f-8c5e-48e7334e5049">정렬해놔야 절반씩 소거하며 찾기가 가능하다.<img width="100" alt="스크린샷 2024-07-20 오후 11 52 15" src="https://github.com/user-attachments/assets/80b18edf-4a88-4fa5-891b-cfc1058d4bdb">> **정렬해놓은 컬럼사본**을 `index` 라고 한다.- 데이터베이스 크기의 약 10% 정도의 저장공간이 필요하다.`age=20` 인 데이터를 찾을 때:- index 없는 경우:1. 모든 행을 다 뒤진다.- index 있는 경우:1. index 에서 age=20 을 빠르게 찾는다.2. index 와 연결된 원래 테이블 행을 가져온다.### 🔋 참고`Primary Key` 로 설정된 컬럼은 자동으로 정렬이 되어 있기 때문에 index 생성이 필요없다. 이를 `클러스터링 인덱스(Clustering Index)` 라고 부른다.  `Unique Key` 로 설정된 컬럼은 `논-클러스터링 인덱스(Non-Clustering Index)` 라고 한다.## ⚡️ Index 의 구조### 🔋 페이지데이터가 저장되는 단위 (16 KByte)### 🔋 Binary Search Tree<img width="600" alt="스크린샷 2024-07-21 오전 4 55 22" src="https://github.com/user-attachments/assets/54f4c00b-07df-4a53-9337-989b623b8e42">> `Binary Search Tree`: `이진 탐색` + `연결리스트`index 는 기본적으로 이런 식으로 Tree 의 형태로 구성되어 있고, 이것을 `Binary Search Tree` 라고 한다.이렇게 하면 1/2 씩 소거하며 데이터를 찾을 수 있다.위의 구조를 좀 더 개선할 수도 있다.### 🔋 B-tree<img width="600" alt="스크린샷 2024-07-21 오전 12 27 34" src="https://github.com/user-attachments/assets/82ded4fb-d4e6-44d8-bb63-53c167714585"><img width="600" alt="스크린샷 2024-07-21 오전 9 57 11" src="https://github.com/user-attachments/assets/c24f3be7-3ba9-4748-96a6-0838ef861c07">> `B-tree`: 트리 높이가 같다 + 자식 노드를 2개 이상 가질 수 있음 + **기본 데이터베이스 인덱스 구조**node 마다 데이터를 하나씩만 넣는 것이 아니라, 2개,3개씩 넣는다.  이렇게 하면 데이터를 반씩 소거하며 찾는 것이 아니라, 2/3씩 소거하며 찾을 수 있다.  이것을 `B-tree` 라고 한다.그런데, 위의 구조를 한번 더 개선할 수 있다.<img width="600" alt="스크린샷 2024-07-21 오전 12 30 28" src="https://github.com/user-attachments/assets/72404bdd-d5ae-4505-afc6-406fc0717520"><img width="600" alt="스크린샷 2024-07-21 오전 12 33 27" src="https://github.com/user-attachments/assets/bce078ea-7837-4380-b99d-d5614f852e88">위의 노드 데이터들엔 데이터 탐색 가이드라인만 제공하고, 맨 밑에만 데이터를 보관한다.  그리고, 맨 밑의 노드들도 서로 연결되어 있다. 그래서, 이동이 매우 쉬워진다.   -> `범위 검색(range search)`에 유리해진다. **화살표를 따라서 이동하면 된다.**예를 들어서, 4~8 어디있나 할 때, 4를 찾은 후에 화살표를 따라 이동해서 8까지 가면 된다.이러한 구조를 `B+tree` 라고 한다.## ⚡️ Index 의 장점1. **검색 성능 향상**: **`WHERE`** 절에서 특정 칼럼을 이용한 조건 검색이 빨라진다. 인덱스가 없으면 데이터베이스 엔진은 테이블 전체를 스캔하여 조건에 맞는 행을 찾아야한다. 하지만 인덱스가 있다면 인덱스를 사용하여 더 빠르게 검색이 가능하다.2. **조인 성능 향상**: **`JOIN`** 절에서 조인할 때 인덱스가 있는 경우, 데이터베이스 엔진은 인덱스를 이용하여 조인을 수행할 수 있다. 이는 두 테이블 간의 매칭되는 행을 효율적으로 찾을 수 있도록 도와준다.3. **정렬 및 그룹화 성능 향상**: 인덱스는 정렬 및 그룹화 작업에도 도움을 준다. 특히, **`ORDER BY`** 나 **`GROUP BY`** 절에서 인덱스를 사용하면 정렬이나 그룹화 작업이 빨라진다.4. **범위 검색 최적화**: 일부 인덱스는 범위 검색에 특히 유용하다. 예를 들어, 날짜 범위나 숫자 범위에 대한 검색에서 인덱스를 사용하면 효율적으로 원하는 결과를 얻을 수 있다.## ⚡️ Index 의 단점<img width="600" alt="스크린샷 2024-07-21 오전 12 45 22" src="https://github.com/user-attachments/assets/d3209b3b-a907-4ee2-bfa5-395a71e1e36a">- index 는 column 을 **복사해서 저장해 놓는 개념**이기 때문에, 이것을 만들 때 마다 **DB 용량**을 잡아먹는다. 검색이 필요 없는 컬럼의 경우 굳이 index 를 만들지 않는다.  - **데이터베이스 크기의 약 10% 정도의 저장공간이 필요하다.**<img width="600" alt="스크린샷 2024-07-21 오전 10 00 51" src="https://github.com/user-attachments/assets/c78a46ea-403b-49fe-b176-b903edb3519a">- insert, delete, update 의 성능에 영향을 미친다. -> `페이지 분할`과 `사용안함 표시`로 **페이지 낭비** 및 **인덱스의 조각화**가 심해져 **성능이 저하**된다.`페이지 분할`:1. **페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생**2. **DB 가 느려지고 성능에 영향을 준다.**- `insert`: 1. 비어있는 페이지 확보, 2. 문제가 있는 페이의 데이터를 공평하게 나누어 저장- `delete`: 인덱스의 데이터를 실제로 **지우지 않고 사용안함 표시(페이지 낭비 및 인덱스 조각화 발생)** 를 한다.- `update`: 1. delete(기존값 사용 안함 표시), 2. insert(변경된 값 삽입)<br/><br/><br/># 💡 Clustering Index, Non-Clustering Index> `Clustering Index`: 실제 데이터와 **같은 무리**의 인덱스> - 실제 데이터가 정렬된 `사전`과 같은 역할>> `Non-Clustering Index`: 실제 데이터와 **다른 무리**의 **별도**의 인덱스> - 실제 데이터 탐색에 도움을 주는 `책의 찾아보기`와 같은 역할<br/>```sqlcreate table sample (    id int primary key,    name varchar(255),    email varchar(255));```- `primary key` 는 `Clustering Index`- `unique` 제약조건은 `Non-Clustering Index`## ⚡️ Clustering Index### 🔋 table 에 Clustering Index 적용방법1. : `primary key` 로 설정```sqlalter table sample ADD CONSTRAINT pk_id PRIMARY KEY (id);```2. : `NOT NULL`, `Unique` 제약 조건을 한번에 걸기```sqlalter table sample ADD CONSTRAINT id int NOT NULL;alter table sample ADD CONSTRAINT unique_id UNIQUE (id);```<br/><br/>### 🔋 Clustering Index 의 구조<img width="1000" alt="스크린샷 2024-08-03 오후 11 43 24" src="https://github.com/user-attachments/assets/954bc910-4b11-4292-88ef-e0cadca8417b">**정렬된 데이터를 기준으로 루트 페이지가 생성되는데**, 루트 페이지와 리프 페이지의 구조는 `B-tree` 의 구조로 되어있다.- 루트 페이지의 1000, 1001, 1002 와 같은 데이터는 **리프 페이지의 주소 값을 나타낸다.**- `데이터 페이지`: 실제 데이터가 저장되는 페이지, **모든 컬럼에 대한 실제 데이터를 담고 있는 페이지**이다.<img width="1000" alt="스크린샷 2024-08-03 오후 11 51 25" src="https://github.com/user-attachments/assets/25e2f46e-b676-4cbc-99e0-8fefb8cbeaa7">```sqlselect *from samplewhere id = 7;```- 7 은 루트 페이지에서 5 와 9 사이에 있고, 리프 페이지의 주소가 1001 이므로 1001 페이지로 이동하여 데이터를 가져온다.<br/><br/>### 🔋 Clustering Index 의 특징1. **실제 데이터 자체**가 **정렬**2. 테이블당 **1개**만 존재 가능3. 리프 페이지가 **데이터 페이지와 동일하다.**4. 아래의 제약조건시 자동생성- `primary key` **(우선 순위)**- `not null` + `unique`<br/><br/>## ⚡️ Non-Clustering Index### 🔋 table 에 Non-Clustering Index 적용방법1. : `unique` 제약조건으로 설정```sqlalter table sample ADD CONSTRAINT unique_email UNIQUE (email);```2. `unique index` 생성: 중복을 허용하지 않는 index 생성```sqlcreate UNIQUE INDEX unq_index_email ON sample (email);```3. `index` 생성: 중복을 허용하는 index 생성```sqlcreate INDEX idx_email ON sample (email);```<br/><br/>### 🔋 Non-Clustering Index 의 구조<img width="1000" alt="스크린샷 2024-08-04 오전 12 09 44" src="https://github.com/user-attachments/assets/24780dfe-2e8a-4266-997c-ecd820c5327c">- 실제 데이터가 저장되어 있는 **데이터 페이지는 어떠한 정렬이나 변경도 이루어지지 않는다.**- 리프 페이지가 실제 데이터가 있는 데이터 페이지가 아니라 **별도의 인덱스 페이지가 추가된다.**- `B-tree` 의 구조를 가지고 있다.- `1002 + #3` 의 경우, 1002 주소를 가진 데이터 페이지의 3번째 데이터를 의미한다.- 앞서 예시를 들었던 것과 같이 책의 내용은 그대로 있고, `책 맨뒤의 찾아보기 페이지`와 같은 역할을 한다.<img width="1000" alt="스크린샷 2024-08-04 오전 12 15 30" src="https://github.com/user-attachments/assets/5bce0169-0dcb-42f4-b7ad-0c9024c8d391">```sqlselect *from samplewhere name = '제로';```<br/><br/>### 🔋 Non-Clustering Index 의 특징1. **실제 데이터 페이지는 그대로 있다.**2. 별도의 인덱스 페이지 생성 필요 -> **추가 공간이 필요하다.**3. 테이블당 **여러개 존재**4. 리프 페이지에 **실제 데이터 페이지 주소**를 담고 있다.5. **`unique` 제약조건 적용시 자동 생성**6. **직접 index 생성시** `Non-Clustering Index` 가 생성된다.<br/><br/><br/>## ⚡️ Clustering Index, Non-Clustering Index 를 함께 적용**예상 구조**<img width="1000" alt="스크린샷 2024-08-04 오전 12 25 57" src="https://github.com/user-attachments/assets/f3d24b42-2048-4c46-b292-855d1e711c2b">- Non-Clustering Index 의 리프 페이지에 실제 데이터 페이지 주소를 담고 있을 것이다.**실제 구조**<img width="1000" alt="스크린샷 2024-08-04 오전 12 28 51" src="https://github.com/user-attachments/assets/bc63b6d6-f5b6-4bb1-aa44-f26938f19d8c">- Clustering Index 가 적용된 값을 갖고 있다.- name 이 "라라" 인 데이터를 탐색할 때, Non-Clustering Index 를 통해 Clustering Index 의 값을 찾고, 해당 값을 Clustering Index 페이지에서 탐색한다.**Non-Clustering Index 의 리프 페이지에서 실제 데이터 페이지 주소를 갖고 있을 때 문제점**<img width="1000" alt="스크린샷 2024-08-04 오전 12 33 35" src="https://github.com/user-attachments/assets/660ac726-18ec-4ad7-99c4-dc002e82a3e3">- **새로운 데이터를 추가 또는 삭제할 때, `페이지 분할`이 발생하고, index 페이지의 `주소 변경`이 발생할 수 있다.**<br/><br/>### 🔋 Clustering Index, Non-Clustering Index 를 함께 적용할 때의 특징> Non-Clustering Index 의 리프 페이지에 <del>**실제 데이터 페이지 주소**</del>를 담고 있다.>> -> <u>**`Clustering Index` 가 적용된 실제 값**</u>- 다른 특징들은 모두 동일하다.<br/><br/><br/># 💡 DB Index 에서 B Tree 계열을 사용하는 이유<img width="800" alt="스크린샷 2024-08-04 오전 3 53 10" src="https://github.com/user-attachments/assets/0704df9e-a02f-47b1-91a1-461290135f66"><br/>## ⚡️ Computer System 의 작동원리<img width="800" alt="스크린샷 2024-08-04 오전 3 56 54" src="https://github.com/user-attachments/assets/edb2dd0f-2bac-447f-a01c-342e36d060e7"><img width="800" alt="스크린샷 2024-08-04 오전 1 34 29" src="https://github.com/user-attachments/assets/376068f1-0dfd-4c84-8d26-985c50dd79ee"><img width="800" alt="스크린샷 2024-08-04 오전 1 35 13" src="https://github.com/user-attachments/assets/dc36144d-1a9f-45ac-b0ff-90daae4431af"><img width="800" alt="스크린샷 2024-08-04 오전 1 35 49" src="https://github.com/user-attachments/assets/675d4342-f43a-4a83-bf38-7b4d01b4e3f3"><img width="800" alt="스크린샷 2024-08-04 오전 1 37 30" src="https://github.com/user-attachments/assets/f3e39164-8036-4845-8fb3-4b0cafa85f73"><br/>## ⚡️ DB System 의 작동원리<img width="800" alt="스크린샷 2024-08-04 오전 1 38 37" src="https://github.com/user-attachments/assets/7d3b7df4-15b0-4326-af32-7c404c26ba5f"><br/>## ⚡️ AVL tree index vs B-tree index 비교 예시<img width="800" alt="스크린샷 2024-08-04 오전 1 39 58" src="https://github.com/user-attachments/assets/6efe21a6-82b9-4d02-ad47-32de24335d37"><br/>### 🔋 AVL tree index 작동방식<img width="800" alt="스크린샷 2024-08-04 오전 1 41 06" src="https://github.com/user-attachments/assets/1b496a56-f515-411f-a7ae-ccfccdd2d224"><img width="800" alt="스크린샷 2024-08-04 오전 1 41 41" src="https://github.com/user-attachments/assets/40c80898-cf0c-4560-90f7-a27d83fa80f7"><img width="800" alt="스크린샷 2024-08-04 오전 2 53 46" src="https://github.com/user-attachments/assets/907bf0c5-77ea-4320-9a38-1e0d0a0a3b7e"><br/>### 🔋 B-tree index 작동방식<img width="800" alt="스크린샷 2024-08-04 오전 3 02 38" src="https://github.com/user-attachments/assets/914797fb-0272-4f77-ab46-663d4ecea51d"><br/>## ⚡️ 자녀 노드 수 비교<img width="800" alt="스크린샷 2024-08-04 오전 3 23 18" src="https://github.com/user-attachments/assets/b3962134-3e8d-4886-bec0-e3fb6ad5c4ea">## ⚡️ 노드의 데이터 수 비교<img width="800" alt="스크린샷 2024-08-04 오전 3 26 18" src="https://github.com/user-attachments/assets/b5ddae49-134e-4906-b138-54b441d69401"><br/>## ⚡️ B-tree index 의 강력함<img width="800" alt="스크린샷 2024-08-04 오전 3 50 20" src="https://github.com/user-attachments/assets/48eccfda-4cf9-49f9-94ca-51e35668f8bc"><img width="800" alt="스크린샷 2024-08-04 오전 3 51 11" src="https://github.com/user-attachments/assets/50532a50-c579-4e0a-b9a2-b682d967d4a4"><img width="800" alt="스크린샷 2024-08-04 오전 3 51 42" src="https://github.com/user-attachments/assets/34f8c535-8639-4599-b540-d0fde8e67af0"><img width="800" alt="스크린샷 2024-08-04 오전 3 52 12" src="https://github.com/user-attachments/assets/ed9893df-b1ea-4f9f-af8b-75f6275a6a72">### 🔋 참고<img width="800" alt="스크린샷 2024-08-04 오전 4 13 00" src="https://github.com/user-attachments/assets/ed3fd9d2-ec68-415d-b67a-4940ce5fb809"><img width="800" alt="스크린샷 2024-08-04 오전 4 16 52" src="https://github.com/user-attachments/assets/a4b6281a-c87c-48de-8305-ea2557bef65f"><br/>## ⚡️ B tree 계열을 DB index 로 사용하는 이유<img width="800" alt="스크린샷 2024-08-04 오전 3 32 56" src="https://github.com/user-attachments/assets/84eb0b27-eb58-4838-ad21-1277c12ade43">### 🔋 Block 안에 최대한 담는다면?<img width="800" alt="스크린샷 2024-08-04 오전 3 48 57" src="https://github.com/user-attachments/assets/301ff071-f60c-45db-811d-96c3c3243bf4">### 🔋 Hash Index 는 사용할 수 없나?- Mysql 등 DB 에서 실제로 제공하는 기능이다.<img width="800" alt="스크린샷 2024-08-04 오전 3 35 43" src="https://github.com/user-attachments/assets/da5c4ab0-c3bc-41e8-a348-947706d4c3c7">B+Tree, AVL Tree, Red-Black Tree 모두 워스트 케이스에 대한 `O(logN)`를 보장한다.  같은 시간복잡도를 제공함에도 DB Index에 굳이 B+Tree를 사용하는 이유는 다음과 같다.DB에서 다루는 데이터는 모두 SSD, HDD 같은 Secondary Storage에 저장된다.    (휘발되어서는 안 되는 중요한 데이터이기 때문 + 용량 문제)Memory 상에 필요한 데이터가 없다면 반드시 Secondary Storage에 접근해서 가져와야 한다.  하지만 Secondary Storage 는 속도가 느린 저장장치이기 때문에 Secondary Storage 에 대한 접근 횟수를 줄이는 것이 성능 향상을 위한 길이다.BST 기반의 Tree들이 한 노드에 하나의 값만을 갖는 것에 비해 B+Tree는 하나의 노드에 여러 값을 가질 수 있다.    즉, 한 번의 접근으로 더 많은 값들에 대한 조회가 가능하기 때문에 Secondary Storage 접근 횟수를 줄일 수 있다.또한 데이터 조회 시 Block 단위로 읽어오는 저장장치의 특성 상 연관된 데이터를 최대한 모아서 저장해놓는 것이 더 효율적이다.    B+Tree의 한 노드 안에서는 물리적으로 연속된 공간에 데이터들이 저장되기 때문에 Block 단위의 조회에서 더 많은 유효데이터를 가져올 수 있다.### 🔋 참고디스크에서의 데이터 엑세스는 바이트 단위가 아니라 블럭 단위로 수행되기 때문에 랜덤 액세스, 포인터 연산이 굉장히 비싸다.알고리즘의 시간복잡도는 일반적으로 포인터 연산의 수행속도가 상수시간으로 일정하다는 RAM 환경을 가정하고 이야기하는 것.<br/><br/><br/># 💡 Index 활용하기## ⚡️ Index 설정 방법**notice 테이블**```sqlCREATE TABLE `notice` (`id` bigint NOT NULL AUTO_INCREMENT,`title` varchar(30) DEFAULT NULL,`content` varchar(100) DEFAULT NULL,`who` varchar(30) DEFAULT NULL,`createDate` timestamp NOT NULL,`updateDate` timestamp NOT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb3;```- 이러한 테이블이 있다고 가정했을 때```sql-- 인덱스 생성CREATE INDEX idx_notice_createDate ON notice ( createDate );-- 인덱스 확인show index from notice;```<br/><br/>## ⚡️ Index 를 설정하는 기준은?> 개발하면서 작성한 쿼리 분석하기: **where , join 등에서 사용하는** 칼럼들 분석하기  (앞서 보았듯이, index 를 걸어주지 않으면 전체 테이블을 대상으로 쿼리를 날린다: Full Table Scan)### **🔋 `where` 절, `join` 절에 `column` 이 여러가지라면?**```sqlSELECT  CONCAT(ROUND(COUNT(DISTINCT id) / COUNT(*) * 100, 2), '%') AS id_cardinality,  CONCAT(ROUND(COUNT(DISTINCT title) / COUNT(*) * 100, 2), '%') AS title_cardinality,  CONCAT(ROUND(COUNT(DISTINCT content) / COUNT(*) * 100, 2), '%') AS content_cardinality,  CONCAT(ROUND(COUNT(DISTINCT who) / COUNT(*) * 100, 2), '%') AS who_cardinality,  CONCAT(ROUND(COUNT(DISTINCT createDate) / COUNT(*) * 100, 2), '%') AS createDate_cardinality,  CONCAT(ROUND(COUNT(DISTINCT updateDate) / COUNT(*) * 100, 2), '%') AS updateDate_cardinalityFROM notice;```<img width="1000" alt="스크린샷 2024-07-21 오전 3 40 26" src="https://github.com/user-attachments/assets/ece36531-117d-4563-9855-c2c43264d216">- column 에 **`카디널리티 수치`** 를 기준으로 설정하기.**(특정 column 이나 관계에서 고유한 값을 가지는 정도)**  - ex) 사람 테이블에 성별 보다 이메일/주민번호는 다른 칼럼에 비해 카디널리티 수치가 높다.(값이 상대적으로 더 unique 하기 때문에)  - 따라서, **unique 한 column 을 기준으로 index 를 설정하는 것이 좋다.**### 🔋Cardinality 수치를 보는 다른 예시 table 사진<img width="1000" alt="스크린샷 2024-08-04 오전 12 42 59" src="https://github.com/user-attachments/assets/df1293dc-d063-4595-bcc3-596ab43a6e65">- `cardinality` 수치(그룹 내 요소의 개수)가 높은 `column`  - == **중복도가 낮은 것**- 위의 예시에서는 id, email, 주빈번호 로 설정하면 좋다.### 🔋 정리1. **Cardinality 수치가 높은(중복도가 낮은) 컬럼**2. **`WHERE`, `JOIN`, `ORDER BY` 절에 자주 사용되는 컬럼**  - 인덱스는 추가 공간이 필요하다.  - 조건 절이 없다면 Full Table Scan 이 발생한다.3. **`INSERT`, `UPDATE`, `DELETE` 가 자주 발생하지 않는 컬럼**4. **규모가 큰 table 에 index 를 적용하는 것이 효과가 좋다.**<br/><br/>## ⚡️ 실행계획을 통해 인덱스 확인하기: explain```sqlexplainSELECT * FROM noticeWHERE createDate BETWEEN '2023-01-15 00:00:00' AND '2023-01-15 23:59:59';```<img width="1000" alt="스크린샷 2024-07-21 오전 4 34 56" src="https://github.com/user-attachments/assets/0e052512-97be-4c63-a3d1-2e2e26e6d265"><img width="1000" alt="스크린샷 2024-07-21 오전 4 35 28" src="https://github.com/user-attachments/assets/ffd737c9-c383-40fb-8fc6-24a8975ab643">- **`id`**: 각 쿼리 블록 또는 서브쿼리에 대해 부여된 고유한 식별자. 여러 서브쿼리가 있는 경우 계층적으로 표현된다.- **`select_type`**: 쿼리의 유형을 나타냅니다. `SIMPLE` 은 `단순한 SELECT 쿼리`를 나타낸다.- **`table`**: 쿼리가 참조하는 테이블의 이름.- **`type`**: 테이블에서 레코드를 읽는 방법을 나타냅니다. 여기서 `range` 는 인덱스를 사용하는 **범위 스캔**을 의미한다.- **`possible_keys`**: 쿼리에서 사용될 수 있는 인덱스 목록. 여기서는 **`idx_notice_createDate`** 인덱스를 사용할 수 있음을 나타낸다.- **`key`**: 실제로 선택된 인덱스. 여기서는 **`idx_notice_createDate`** 인덱스가 선택되었다.- **`Extra`**: 기타 정보. 여기서 **`"Using index condition"`** 은 인덱스 조건을 사용하여 필터링 되었음을 나타낸다.> 따라서 주어진 **`EXPLAIN`** 결과는 **`notice`** 테이블에 대한 단순한 **`SELECT`** 쿼리가 있으며, **`idx_notice_createDate`** 인덱스가 사용되어 **`범위 스캔을 수행`** 하고 있다는 것을 나타냅니다.   > **`"Using index condition"`** 은 **인덱스의 조건을 사용하여 레코드를 필터링** 했음을 나타냅니다.<br/><br/>## ⚡️ Index 가 타지 않는 경우가 있다?### 🔋 1. 함수나 연산자를 사용하는 경우:쿼리에서 컬럼 값에 함수나 연산을 적용하면 인덱스가 효과적으로 사용되지 않을 수 있다.- 예를 들어,` WHERE UPPER(column_name) = 'VALUE'` 와 같이 함수를 사용하는 경우에는 인덱스가 효과적으로 사용되지 않을 수 있다.```sql-- createDate에 함수를 사용explainSELECT * FROM notice WHERE DATE_FORMAT(createDate, '%Y-%m-%d') = '2023-05-06';```<img width="1000" alt="스크린샷 2024-07-21 오전 4 45 06" src="https://github.com/user-attachments/assets/1b79f486-abcc-40df-803a-d62d73307741">### 🔋 2. LIKE문 검색에서 와일드카드의 위치:LIKE 연산자를 사용하는 경우, 와일드카드`(%, _)`가 **문자열의 시작 부분**에 위치하면 인덱스가 효과적으로 사용되지 않을 수 있다.- 예를 들어, `LIKE '%pattern'` 형태의 쿼리는 인덱스를 활용할 수 없게 된다.```sql-- 와일드카드가 선행하는 LIKE 검색:explainSELECT * FROM notice WHERE createDate LIKE '%2023-12%';explainSELECT * FROM notice WHERE createDate LIKE '%2023-12';```<img width="1000" alt="스크린샷 2024-07-21 오전 4 45 41" src="https://github.com/user-attachments/assets/472e0f42-8579-449b-9bc9-c73172cd733f">### 🔋 3. OR절을 사용하는 경우:OR 절을 사용하는 경우, 해당 조건들 간에는 최적화가 어려울 수 있다.- 개별 조건이 인덱스를 사용할 수 있더라도, OR 절은 최적화를 어렵게 만들 수 있다.### 🔋 4. NULL 값을 비교하는 경우:특정 컬럼에 대해 NULL 값을 검색하는 경우, 인덱스가 효과적으로 사용되지 않을 수 있다.- **NULL 값은 인덱스에 별도의 처리가 필요하므로 주의가 필요하다.**```sql-- NULL 값을 사용하는 경우:explainSELECT * FROM notice WHERE createDate IS NULL;```<img width="1000" alt="스크린샷 2024-07-21 오전 4 46 19" src="https://github.com/user-attachments/assets/056e3b97-8700-42f1-8eec-ffe895460ed4">### 🔋 5. 컬럼의 자료형이 다른 검색을 하는 경우:컬럼의 자료형이 서로 다른 경우, 인덱스가 효과적으로 사용되지 않을 수 있다.- 자료형이 다르면 인덱스의 키와 비교할 값의 자료형이 일치하지 않아 인덱스를 사용할 수 없게 된다.### 🔋 6. IN 연산자를 사용한 검색에서 IN 목록의 개수가 많은 경우:IN 연산자를 사용하여 검색하는 경우, IN 목록의 개수가 많을수록 인덱스의 효과가 감소할 수 있다.- **많은 항목을 비교하는 경우에는 인덱스를 사용하는 것보다 다른 최적화 전략을 고려해야 한다.**```sql-- IN 연산자와 목록이 많은 경우:explainSELECT * FROM notice WHERE createDate IN ('2023-01-15 14:41:49','2023-05-07 14:50:25', '2023-03-04 14:41:49', '2023-03-01 14:41:49'...'2023-05-06 17:43:51','2023-05-06 17:43:52');```<img width="1000" alt="스크린샷 2024-07-21 오전 4 46 53" src="https://github.com/user-attachments/assets/afb18b81-215f-490d-98ad-dedb1e281d38"><br/><br/>## ⚡️ Index 가 타지 않을 때: HINT 활용하기> **HINT 활용하기****데이터베이스 엔진이 최적에 쿼리 실행을 결정 하겠지만 상황에 따라서 개발자가 확인을 하여 쿼리 개선을 해줘야하는 경우도 간혹 있다.**- ex) 테이블에 A, B 라는 인덱스가 있고 쿼리 성능이 좋지 않아 실행계획을 확인 해보니 `Cardinality 수치`가 좋지 않은 B 라는 인덱스를 타고 있는 상황- **A 인덱스가 Cardinality 수치가 더 좋아 힌트 기능을 활용하여 강제로 A 인덱스를 타도록 설정하여 성능결과 확인하기.**```sqlSELECT * FROM {table} use index(A인덱스)``````sqlCREATE INDEX idx_notice_who ON notice ( who );show index from notice;explainSELECT * FROM noticeWHERE who = 'userA'andcreateDate BETWEEN '2024-01-11 00:00:00' AND '2024-01-11 23:59:59';// 힌트 기능을 사용해서 강제로 idx_notice_who 인덱스를 타도록 하기.explainSELECT * FROM notice use index(idx_notice_who)WHERE who = 'userA'andcreateDate BETWEEN '2024-01-11 00:00:00' AND '2024-01-11 23:59:59';```<br/><br/>## ⚡️ Index 사용시 주의사항1. **잘 활용되지 않는 index 는 과감히 제거하자.**  - Where 절에 사용되더라도 자주 사용해야 가치가 있다.  - 불필요한 index 로 인해 성능 저하가 발생할 수 있다.2. **데이터 중복도가 높은 컬럼은 index 효과가 적다.**3. **자주 사용되더라도 `INSERT`, `UPDATE`, `DELETE` 가 자주 일어나는지 고려해야 한다.**  - 일반적인 웹 서비와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기의 비율은 8:2, 9:1 이다.  - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.## ⚡️ Reference- https://www.youtube.com/watch?v=edpYzFgHbqs&t=216s- https://www.youtube.com/watch?v=iNvYsGKelYs&t=154s- https://www.youtube.com/watch?v=liPSnc6Wzfk- https://www.youtube.com/watch?v=bqkcoSm_rCs&t=1606s- https://www.youtube.com/watch?v=liPSnc6Wzfk- https://www.inflearn.com/course/%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0-%EC%B4%88%EC%84%9D-%EB%8B%A4%EC%A7%80%EA%B8%B0/dashboard