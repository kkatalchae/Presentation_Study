# Database Index (feat. MySQL)# 💡 Index 란?<img width="200" alt="스크린샷 2024-07-20 오후 11 49 22" src="https://github.com/user-attachments/assets/5d9baa64-0716-4d0f-8c5e-48e7334e5049">정렬해놔야 절반씩 소거하며 찾기가 가능하다.<img width="100" alt="스크린샷 2024-07-20 오후 11 52 15" src="https://github.com/user-attachments/assets/80b18edf-4a88-4fa5-891b-cfc1058d4bdb">> **정렬해놓은 컬럼사본**을 `index` 라고 한다.- 데이터베이스 크기의 약 10% 정도의 저장공간이 필요하다.age=20 인 데이터를 찾을 때:- index 없는 경우:1. 모든 행을 다 뒤진다.- index 있는 경우:1. index 에서 age=20 을 빠르게 찾는다.2. index 와 연결된 원래 테이블 행을 가져온다.### 🔋 참고`Primary Key` 로 설정된 컬럼은 자동으로 정렬이 되어 있기 때문에 index 생성이 필요없다. 이를 `클러스터링 인덱스(Clustering Index)` 라고 부른다.`Unique Key` 로 설정된 컬럼은 `논-클러스터링 인덱스(Non-Clustering Index)` 라고 한다.## ⚡️ Index 의 구조### 🔋 페이지데이터가 저장되는 단위 (16 KByte)### 🔋 Binary Search Tree<img width="600" alt="스크린샷 2024-07-21 오전 4 55 22" src="https://github.com/user-attachments/assets/54f4c00b-07df-4a53-9337-989b623b8e42">> `Binary Search Tree`: `이진 탐색` + `연결리스트`index 는 기본적으로 이런 식으로 Tree 의 형태로 구성되어 있고, 이것을 `Binary Search Tree` 라고 한다.이렇게 하면 1/2 씩 소거하며 데이터를 찾을 수 있다.위의 구조를 좀 더 개선할 수도 있다.### 🔋 B-tree<img width="600" alt="스크린샷 2024-07-21 오전 12 27 34" src="https://github.com/user-attachments/assets/82ded4fb-d4e6-44d8-bb63-53c167714585"><img width="1640" alt="스크린샷 2024-07-21 오전 9 57 11" src="https://github.com/user-attachments/assets/c24f3be7-3ba9-4748-96a6-0838ef861c07">> `B-tree`: 트리 높이가 같다 + 자식 노드를 2개 이상 가질 수 있음 + **기본 데이터베이스 인덱스 구조**node 마다 데이터를 하나씩만 넣는 것이 아니라, 2개,3개씩 넣는다.  이렇게 하면 데이터를 반씩 소거하며 찾는 것이 아니라, 2/3씩 소거하며 찾을 수 있다.  이것을 `B-tree` 라고 한다.그런데, 위의 구조를 한번 더 개선할 수 있다.<img width="600" alt="스크린샷 2024-07-21 오전 12 30 28" src="https://github.com/user-attachments/assets/72404bdd-d5ae-4505-afc6-406fc0717520"><img width="600" alt="스크린샷 2024-07-21 오전 12 33 27" src="https://github.com/user-attachments/assets/bce078ea-7837-4380-b99d-d5614f852e88">위의 노드 데이터들엔 데이터 탐색 가이드라인만 제공하고, 맨 밑에만 데이터를 보관한다.  그리고, 맨 밑의 노드들도 서로 연결되어 있다. 그래서, 이동이 매우 쉬워진다.   -> `범위 검색(range search)`에 유리해진다. **화살표를 따라서 이동하면 된다.**예를 들어서, 4~8 어디있나 할 때, 4를 찾은 후에 화살표를 따라 이동해서 8까지 가면 된다.이러한 구조를 `B+tree` 라고 한다.## ⚡️ Index 의 장점1. **검색 성능 향상**: **`WHERE`** 절에서 특정 칼럼을 이용한 조건 검색이 빨라진다. 인덱스가 없으면 데이터베이스 엔진은 테이블 전체를 스캔하여 조건에 맞는 행을 찾아야한다. 하지만 인덱스가 있다면 인덱스를 사용하여 더 빠르게 검색이 가능하다.2. **조인 성능 향상**: **`JOIN`** 절에서 조인할 때 인덱스가 있는 경우, 데이터베이스 엔진은 인덱스를 이용하여 조인을 수행할 수 있다. 이는 두 테이블 간의 매칭되는 행을 효율적으로 찾을 수 있도록 도와준다.3. **정렬 및 그룹화 성능 향상**: 인덱스는 정렬 및 그룹화 작업에도 도움을 준다. 특히, **`ORDER BY`** 나 **`GROUP BY`** 절에서 인덱스를 사용하면 정렬이나 그룹화 작업이 빨라진다.4. **범위 검색 최적화**: 일부 인덱스는 범위 검색에 특히 유용하다. 예를 들어, 날짜 범위나 숫자 범위에 대한 검색에서 인덱스를 사용하면 효율적으로 원하는 결과를 얻을 수 있다.## ⚡️ Index 의 단점<img width="600" alt="스크린샷 2024-07-21 오전 12 45 22" src="https://github.com/user-attachments/assets/d3209b3b-a907-4ee2-bfa5-395a71e1e36a">- index 는 column 을 **복사해서 저장해 놓는 개념**이기 때문에, 이것을 만들 때 마다 **DB 용량**을 잡아먹는다. 검색이 필요 없는 컬럼의 경우 굳이 index 를 만들지 않는다.    - **데이터베이스 크기의 약 10% 정도의 저장공간이 필요하다.**<img width="1613" alt="스크린샷 2024-07-21 오전 10 00 51" src="https://github.com/user-attachments/assets/c78a46ea-403b-49fe-b176-b903edb3519a">- insert, delete, update 의 성능에 영향을 미친다. -> `페이지 분할`과 `사용안함 표시`로 **페이지 낭비** 및 **인덱스의 조각화**가 심해져 **성능이 저하**된다.`페이지 분할`:1. **페이지에 새로운 데이터를 추가할 여유공간이 없어 페이지에 변화가 발생**2. **DB 가 느려지고 성능에 영향을 준다.**`insert`: 1. 비어있는 페이지 확보, 2. 문제가 있는 페이의 데이터를 공평하게 나누어 저장`delete`: 인덱스의 데이터를 실제로 **지우지 않고 사용안함 표시(페이지 낭비 및 인덱스 조각화 발생)** 를 한다.`update`: 1. delete(기존값 사용 안함 표시), 2. insert(변경된 값 삽입)<br/><br/><br/># 💡 Index 활용하기## Index 설정 방법**notice 테이블**```sqlCREATE TABLE `notice` (`id` bigint NOT NULL AUTO_INCREMENT,`title` varchar(30) DEFAULT NULL,`content` varchar(100) DEFAULT NULL,`who` varchar(30) DEFAULT NULL,`createDate` timestamp NOT NULL,`updateDate` timestamp NOT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb3;```- 이러한 테이블이 있다고 가정했을 때```sql-- 인덱스 생성CREATE INDEX idx_notice_createDate ON notice ( createDate );-- 인덱스 확인show index from notice;```## ⚡️ Index 를 설정하는 기준은?> 개발하면서 작성한 쿼리 분석하기: **where , join 등에서 사용하는** 칼럼들 분석하기  (앞서 보았듯이, index 를 걸어주지 않으면 전체 테이블을 대상으로 쿼리를 날린다: Full Table Scan)### **🔋 `where` 절, `join` 절에 `column` 이 여러가지라면?**```sqlSELECT  CONCAT(ROUND(COUNT(DISTINCT id) / COUNT(*) * 100, 2), '%') AS id_cardinality,  CONCAT(ROUND(COUNT(DISTINCT title) / COUNT(*) * 100, 2), '%') AS title_cardinality,  CONCAT(ROUND(COUNT(DISTINCT content) / COUNT(*) * 100, 2), '%') AS content_cardinality,  CONCAT(ROUND(COUNT(DISTINCT who) / COUNT(*) * 100, 2), '%') AS who_cardinality,  CONCAT(ROUND(COUNT(DISTINCT createDate) / COUNT(*) * 100, 2), '%') AS createDate_cardinality,  CONCAT(ROUND(COUNT(DISTINCT updateDate) / COUNT(*) * 100, 2), '%') AS updateDate_cardinalityFROM notice;```<img width="1000" alt="스크린샷 2024-07-21 오전 3 40 26" src="https://github.com/user-attachments/assets/ece36531-117d-4563-9855-c2c43264d216">- column 에 **`카디널리티 수치`** 를 기준으로 설정하기.**(특정 column 이나 관계에서 고유한 값을 가지는 정도)**    - ex) 사람 테이블에 성별 보다 이메일/주민번호는 다른 칼럼에 비해 카디널리티 수치가 높다.(값이 상대적으로 더 unique 하기 때문에)    - 따라서, **unique 한 column 을 기준으로 index 를 설정하는 것이 좋다.**## ⚡️ 실행계획을 통해 인덱스 확인하기: explain```sqlexplainSELECT * FROM noticeWHERE createDate BETWEEN '2023-01-15 00:00:00' AND '2023-01-15 23:59:59';```<img width="1000" alt="스크린샷 2024-07-21 오전 4 34 56" src="https://github.com/user-attachments/assets/0e052512-97be-4c63-a3d1-2e2e26e6d265"><img width="1000" alt="스크린샷 2024-07-21 오전 4 35 28" src="https://github.com/user-attachments/assets/ffd737c9-c383-40fb-8fc6-24a8975ab643">- **`id`**: 각 쿼리 블록 또는 서브쿼리에 대해 부여된 고유한 식별자. 여러 서브쿼리가 있는 경우 계층적으로 표현된다.- **`select_type`**: 쿼리의 유형을 나타냅니다. `SIMPLE` 은 `단순한 SELECT 쿼리`를 나타낸다.- **`table`**: 쿼리가 참조하는 테이블의 이름.- **`type`**: 테이블에서 레코드를 읽는 방법을 나타냅니다. 여기서 `range` 는 인덱스를 사용하는 **범위 스캔**을 의미한다.- **`possible_keys`**: 쿼리에서 사용될 수 있는 인덱스 목록. 여기서는 **`idx_notice_createDate`** 인덱스를 사용할 수 있음을 나타낸다.- **`key`**: 실제로 선택된 인덱스. 여기서는 **`idx_notice_createDate`** 인덱스가 선택되었다.- **`Extra`**: 기타 정보. 여기서 **`"Using index condition"`** 은 인덱스 조건을 사용하여 필터링 되었음을 나타낸다.> 따라서 주어진 **`EXPLAIN`** 결과는 **`notice`** 테이블에 대한 단순한 **`SELECT`** 쿼리가 있으며, **`idx_notice_createDate`** 인덱스가 사용되어 **`범위 스캔을 수행`** 하고 있다는 것을 나타냅니다.   > **`"Using index condition"`** 은 **인덱스의 조건을 사용하여 레코드를 필터링** 했음을 나타냅니다.<br/><br/>## ⚡️ Index 가 타지 않는 경우가 있다?### 🔋 1. 함수나 연산자를 사용하는 경우:쿼리에서 컬럼 값에 함수나 연산을 적용하면 인덱스가 효과적으로 사용되지 않을 수 있다.- 예를 들어,` WHERE UPPER(column_name) = 'VALUE'` 와 같이 함수를 사용하는 경우에는 인덱스가 효과적으로 사용되지 않을 수 있다.```sql-- createDate에 함수를 사용explainSELECT * FROM notice WHERE DATE_FORMAT(createDate, '%Y-%m-%d') = '2023-05-06';```<img width="1728" alt="스크린샷 2024-07-21 오전 4 45 06" src="https://github.com/user-attachments/assets/1b79f486-abcc-40df-803a-d62d73307741">### 🔋 2. LIKE문 검색에서 와일드카드의 위치:LIKE 연산자를 사용하는 경우, 와일드카드`(%, _)`가 **문자열의 시작 부분**에 위치하면 인덱스가 효과적으로 사용되지 않을 수 있다.- 예를 들어, `LIKE '%pattern'` 형태의 쿼리는 인덱스를 활용할 수 없게 된다.```sql-- 와일드카드가 선행하는 LIKE 검색:explainSELECT * FROM notice WHERE createDate LIKE '%2023-12%';explainSELECT * FROM notice WHERE createDate LIKE '%2023-12';```<img width="1442" alt="스크린샷 2024-07-21 오전 4 45 41" src="https://github.com/user-attachments/assets/472e0f42-8579-449b-9bc9-c73172cd733f">### 🔋 3. OR절을 사용하는 경우:OR 절을 사용하는 경우, 해당 조건들 간에는 최적화가 어려울 수 있다.- 개별 조건이 인덱스를 사용할 수 있더라도, OR 절은 최적화를 어렵게 만들 수 있다.### 🔋 4. NULL 값을 비교하는 경우:특정 컬럼에 대해 NULL 값을 검색하는 경우, 인덱스가 효과적으로 사용되지 않을 수 있다.- **NULL 값은 인덱스에 별도의 처리가 필요하므로 주의가 필요하다.**```sql-- NULL 값을 사용하는 경우:explainSELECT * FROM notice WHERE createDate IS NULL;```<img width="1728" alt="스크린샷 2024-07-21 오전 4 46 19" src="https://github.com/user-attachments/assets/056e3b97-8700-42f1-8eec-ffe895460ed4">### 🔋 5. 컬럼의 자료형이 다른 검색을 하는 경우:컬럼의 자료형이 서로 다른 경우, 인덱스가 효과적으로 사용되지 않을 수 있다.- 자료형이 다르면 인덱스의 키와 비교할 값의 자료형이 일치하지 않아 인덱스를 사용할 수 없게 된다.### 🔋 6. IN 연산자를 사용한 검색에서 IN 목록의 개수가 많은 경우:IN 연산자를 사용하여 검색하는 경우, IN 목록의 개수가 많을수록 인덱스의 효과가 감소할 수 있다.- **많은 항목을 비교하는 경우에는 인덱스를 사용하는 것보다 다른 최적화 전략을 고려해야 한다.**```sql-- IN 연산자와 목록이 많은 경우:explainSELECT * FROM notice WHERE createDate IN ('2023-01-15 14:41:49','2023-05-07 14:50:25', '2023-03-04 14:41:49', '2023-03-01 14:41:49'...'2023-05-06 17:43:51','2023-05-06 17:43:52');```<img width="1728" alt="스크린샷 2024-07-21 오전 4 46 53" src="https://github.com/user-attachments/assets/afb18b81-215f-490d-98ad-dedb1e281d38">## ⚡️ Index 가 타지 않을 때: HINT 활용하기> **HINT 활용하기****데이터베이스 엔진이 최적에 쿼리 실행을 결정 하겠지만 상황에 따라서 개발자가 확인을 하여 쿼리 개선을 해줘야하는 경우도 간혹 있다.**- ex). 테이블에 A , B 라는 인덱스가 있고 쿼리 성능이 좋지 않아 실행계획을 확인 해보니 Cardinality 수치가 좋지 않은 B 라는 인덱스를 타고 있는 상황- **A 인덱스가 Cardinality 수치가 더 좋아 힌트 기능을 활용하여 강제로 A 인덱스를 타도록 설정하여 성능결과 확인하기.**```sqlSELECT * FROM {table} use index(A인덱스)``````sqlCREATE INDEX idx_notice_who ON notice ( who );show index from notice;explainSELECT * FROM noticeWHERE who = 'userA'andcreateDate BETWEEN '2024-01-11 00:00:00' AND '2024-01-11 23:59:59';// 힌트 기능을 사용해서 강제로 idx_notice_who 인덱스를 타도록 하기.explainSELECT * FROM notice use index(idx_notice_who)WHERE who = 'userA'andcreateDate BETWEEN '2024-01-11 00:00:00' AND '2024-01-11 23:59:59';```## ⚡️ Reference- https://www.youtube.com/watch?v=edpYzFgHbqs&t=216s- https://www.youtube.com/watch?v=iNvYsGKelYs&t=154s- https://www.inflearn.com/course/%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0-%EC%B4%88%EC%84%9D-%EB%8B%A4%EC%A7%80%EA%B8%B0/dashboard