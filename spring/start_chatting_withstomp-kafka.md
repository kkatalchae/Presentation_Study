# 채팅 기능 구현하기

0. 목차
1. 요구사항
    1. 기존 환경
    2. 요구사항
2. 기본적인 채팅 동작방식
    1. 성능 테스트를 위한 고려사항
3. 구현
    1. 채택한 기술 및 이유
    2. 실제 사용
    3. 겪은 문제상황들
4. 개선사항


======================================================================

## 1. 요구사항

### 1. 기존 환경

- 채팅이 주된 기능 중 하나인 서비스. 
- 클라이언트 친화적인 기능(파이어베이스 사용 및 대부분의 기능들이 클라이언트(앱) 중심으로 구현되어 있음)
- RDB(Mysql-single) 사용 
- 다중(multi) 인스턴스 환경

### 2. 요구사항

> _2주 안으로 기존 채팅 기능을 분석하고, 서버에서 다시 채팅 기능을 만들어 주세요._

1. 왜 채팅 기능을 새로 구현해야 하나요?
   - 현재 앱에 최적화된 채팅기능이라, 웹 환경에서 사용하는 것이 불가.
   - 앱, 웹 환경 둘 다 사용할 수 있어야 합니다.
2. 기존 구현되어 있는 채팅 기능은 무엇인가요?
   - 누구나 채팅방을 만들 수 있습니다.
   - 기존 채팅방 입장 시, 채팅 이력을 불러올 수 있어야 합니다.
   - 기본적으로 1:1이지만,이후 단체 채팅도 고려해야합니다.
   - 읽음표시, 참여중인 채팅이 아닐 경우 push로 알림이 필요합니다.
3. 기간산정?
   - 가급적 빠르게 개발해야 합니다.
   - 이전에 채팅을 개발해본적이 없습니다. 
   
## 2. 기본적인 채팅의 동작 방식

### 1. 프로토콜 선택
   - HTTP 프로토콜 
     - 단방향. 무상태의 특징
     - 전송용도로는 괜찮지만, 수신의 경우 복잡함
     - HTTP는 클라이언트가 연결을 만들며, 서버에서 임의 시점에 메세지를 보내는 것은 어려움.
   - 웹소켓
     - 실시간 양방향 통신 가능, stateful
     - 서버당 연결 가능한 클라이언트 수 제한됨
     - 서버와 connection을 유지하기 위해 리소스 낭비될 수 있음. 
### 2. 데이터 저장
   - RDB vs Nosql
     - RDB
       - 지정된(구조화 된) 형식
       - row 단위
       - 트랜잭션에 엄격함
       - 수평적 확장 < 수직적 확장
     - Nosql
       - 수평적 확장이 RDB보다 용이함 (확장성이 좋음)
       - 트랜잭션 처리 불가
### 3. Message Broker
   - Publisher가 보낸 메세지를 Subscriber로 전달해주는 중간다리 역할.
   - scale-out 용이
   - 토픽, 또는 채널이라는 개념이 존재함.
   - Publisher가 특정 토픽에 대해 메시지를 발행하면 해당 토픽을 구독하고 있는 모든 Subscriber에게 브로커가 메시지를 전달함.

## 3. 구현

> 가장 중요한 것은 개발 속도입니다.

### 1. 채택한 기술
#### 1. web socket(stomp)
   1. 웹소켓
      - 연결이 계속 유지되므로, 굳이 채팅과 같이 실시간성을 요하는 서비스에서 http를 고집할 이유가 없다고 판단.
   2. STOMP(sub-protocol, Simple Text Oriented Messaging Protocol)
      - 웹소켓 자체는 메세지를 주고받는 형식이 정해져 있지 않음.
        <br> -> 따라서, 해당 메시지가 어떤 요청인지, 어떤 포맷인지, 메시지 통신 과정을 어떻게 처리해야하는지 일일히 구현해야 함.
      - STOMP를 sub-protocol로 사용하면, 메시지의 형식, 유형, 내용등을 미리 정의해줌.
      - 메시지의 송수신에 대한 처리를 명확하게 처리 가능함.
      - 스프링에서 spring-websocket 모듈을 통해 STOMP를 제공함
      - @MessageMapping과 같은 어노테이션을 사용하여 메시지 발행 시 엔드포인트 분리하여 관리 가능
#### 2. DB
   - nosql을 고려하였으나, 기존 채팅 데이터가 RDB에 저장되어 있어 짧은 개발 기간동안 데이터 마이그레이션까지 신경쓰기 어렵다고 판단.
   - 추후 데이터가 늘어남을 고려한다면 충분한 기간을 잡고 채팅방 데이터는 RDB, 채팅 내용 데이터는 Nosql 사용 고려

#### 3. External Broker
   - STOMP 사용 시, In-memory Broker인 SimpleBroker를 사용함.
   - 서버 인스턴스가 여러 대 존재할 때, 상태에 대한 동기화가 제대로 이뤄지지 않을 수 있음.
   - 장애 발생 시 메시지 유실 가능성 있음
   - 따로 모니터링하기 어려움
   - kafka 사용
     - 최대 1GB의 메시지 크기 지원
     - 메시징 수준에서의 오류 처리 가능, 배달받지 못한 메시지에 대해 이벤트 재시도 및 리디렉션 가능
     - 병렬처리(여러 Sub이 동일한 메시지 동시에 검색할 수 있음)가능
     - 짧은 지연 시간. 
     - 파티션을 다른 브로커에 자동으로 백업함
     - 메시지 전달 후에도 보관

### 2. 실제 흐름도



## 4. 개선
### 1. 서버 분리
1. 무상태 서비스와 상태 유지가 필요한 서비스로 분리
   - 기본적으로 상태를 유지할 필요가 없는 로그인, 회원가입, 상품 등록, 조회등의 api 서버
   - 클라이언트와 서버가 계속해서 상태를 유지해야하고, 서버 당 연결 제한 수가 있는 채팅서버
   - 제 3의 서비스와 연결이 필요하며 알림이 분실되는 것을 막기 위한 별도의 알림서버
   - SPOF(Single Point Of Failure) 방지, 트래픽 분산을 위해 서버 분리의 필요성을 느꼈으나  
   짧은 개발 기간으로 나누지 못함.
   
### 2. 캐싱 전략 사용
   - look aside cache
     - 캐시에 데이터의 존재 유무를 확인하고, 있으면 캐시에서 가져오고 없으면 db에 접근해서 가져온 뒤 캐시에도 저장
   - write back
     - 데이터를 캐시에 저장하고, 캐시에 있는 데이터를 일정 기간동안 보관하다가 한번에 DB에 접근하여 저장 후 캐시에 있는 데이터를 삭제하는 방식
   - 추후 캐싱 전략을 사용함으로써, RDB 잦은 커넥션을 줄일 수 있음.

### 3. 기타
   - 짧은 기간동안 개발을 하다보니, 메시지가 유실된 상황에 대한 테스트가 이뤄지지 않음.
   - kafka를 사용하며 활용할 수 있는 기능을 온전하게 활용하지 못한 것에 대한 아쉬움.
   - 추후 알림 기능 고도화를 하게 된다면, MQ에 대해 더 깊게 알아보고 조사 해야겠다는 생각.