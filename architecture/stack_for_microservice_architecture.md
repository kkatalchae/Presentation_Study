
## 서론

---

앞서 모놀리식, 마이크로서비스 아키텍처의 개념과 차이점에 대해 살펴봤다.

마이크로서비스 아키텍처가 트렌드로 부상함에 따라 마이크로서비스가 무조건 좋다라고 생각하는 관점은 옳지 않다라는 생각이 들었을 것이다.

두 아키텍처 간의 차이점을 명확히 알고 왜 우리 서비스가 마이크로서비스 아키텍처를 채택해야하는지 명확하게 알고 채택하자.

또한, 마이크로서비스 아키텍처의 장점을 100% 활용하기 위해서는 많은 준비가 필요하다는 것을 알게 되었다.

이제는 마이크로서비스 아키텍처를 사용하기 위해 우리 팀은 어떤 기술에 대한 선행학습이 필요한지 알아보자.


## 마이크로서비스를 위해 필요한 기술 스택


### 컨테이너 기술

---

대표적인 서비스는 `Docker` 가 있다.

컨테이너는 가상화 기술을 이용하여 어플리케이션과 개발 경을 격리된 공간에서 실행하는 단위를 말한다.

도커는 이러한 컨테이너를 기반으로 하는 가상화 플랫폼이다. 

Window 운영체제에서 Ubuntu 를 사용하려고 VirtualBox 와 같은 툴을 통해 가상화 방식을 경험해본 이들도 있을 것이다.

하지만 도커의 가상화 기술과 VirtualBox 와 같은 Virtual Machine 은 큰 차이가 존재한다. 

<br>

![도커와 가상머신 차이](../images/가상머신_도커.jpeg)

<br>

가장 결정적인 차이는 가상 머신에 비해 컨테이너 기술이 가볍고 빠르다는 점이다. 

가상 머신은 기존의 컴퓨팅 리소스에 하이퍼바이저라는 것을 통해서 기존 OS 위에서 여러 OS 가 동작할 수 있도록 리소스를 가상화하고 분배합니다.

반면 컨테이너 기술을 기존 컴퓨팅 자원의 운영체제를 커널을 통해 공유함으로서 가볍게 리소스를 가상화하여 격리된 공간으로 분배할 수 있습니다. 


<br>

> **하이퍼바이저란?**
> 
> 하이퍼바이저는 단일 물리적 머신에서 여러 가상 머신을 실행하는 데 사용할 수 있는 소프트웨어입니다. 모든 가상 머신에는 고유한 운영 체제와 애플리케이션이 있습니다. 하이퍼바이저는 필요에 따라 CPU 및 메모리와 같은 기본 물리적 컴퓨팅 리소스를 개별 가상 머신에 할당합니다. 따라서 물리적 IT 인프라의 최적 사용을 지원합니다.
>
> **커널이란?**
> 
> 커널은 운영 체제의 핵심이며, 하드웨어 리소스를 관리하고 프로세스 간의 통신을 조정합니다. 
> 또한 주변 장치와 상호 작용하여 파일 시스템, 메모리 관리, 네트워킹 등과 같은 기능을 제공합니다. 
> 커널은 시스템의 안정성, 보안, 성능에 매우 중요한 역할을 합니다.

<br>

`왜 마이크로서비스에서는 컨테이너 기술이 중요할까?`

- **독립성과 격리**: 컨테이너는 각각의 서비스를 격리된 환경에서 실행시킵니다. 이는 서비스 간의 상호 작용이나 충돌을 방지하고, 개별 서비스의 독립성을 보장합니다.
- **확장성**: 컨테이너는 가벼우며 빠르게 생성되고 제거될 수 있어서 서비스의 확장이 용이합니다. 필요에 따라 서비스 인스턴스를 쉽게 늘리거나 줄일 수 있습니다.
- **유연성**: 컨테이너는 여러 플랫폼에서 실행될 수 있습니다. 개발 환경, 테스트 환경, 프로덕션 환경 등에서 일관되게 동작합니다.
- **자동화와 관리 용이성**: 컨테이너 기술은 배포, 확장, 모니터링, 로깅 등과 같은 운영 작업을 자동화하고 편리하게 관리할 수 있도록 합니다. 이는 시스템을 효율적으로 운영할 수 있게 해줍니다.
- **환경 일관성**: 컨테이너는 패키지화된 소프트웨어와 그 실행 환경을 함께 제공하기 때문에 서비스의 환경 일관성을 유지할 수 있습니다. 이는 배포 과정에서 발생할 수 있는 문제를 줄여줍니다.
- **비용 절감**: 가상화된 컨테이너는 더 적은 자원을 사용하므로 하드웨어 리소스를 효율적으로 활용할 수 있고, 클라우드 환경에서는 비용을 절감할 수 있습니다.

예를 들어, 각각의 개발자의 개인 PC 에 개발 환경을 세팅한다고 가정해보자.

각 개발자가 사용하는 PC 의 운영체제가 다르다면 node, java 를 설치하고 실행하는데 필요한 명령어가 상이하기 때문에 이에 맞게 명령어를 찾아서 실행해줘야 한다.
또한, 어플리케이션에 필요한 메모리와 같은 컴퓨팅 리소스가 변한다면 어플리케이션을 실행하려는 모든 PC 에서 세팅 값을 수정해줘야 한다.

도커를 사용하게 되면 컴퓨팅 리소스에 대한 설정 값, 운영체제, 배포 스크립트와 같은 어플리케이션 실행에 필요한 세팅들을 코드로 작성할 수 있다. 

코드로 작성된 도커 파일을 공유하면 개인의 PC 에서 동일한 세팅이 보장되는 것이다. 이것이 얼마나 아름다운 일인지는 개발 환경을 세팅을 해본 사람이라면 누구나 알 수 있을 것이다. 

### 컨테이너 오케스트레이션 기술

---

대표적인 서비스로는 Google 에서 개발한 Kubernetes 가 있다. 

컨테이너 오케스트레이션은 여러 개의 컨테이너를 자동으로 배포, 관리, 확장하고 조정하는 기술이다. 이는 대규모 분산 애플리케이션을 구축하고 운영하는 데 필요한 작업을 자동화하여 개발자와 운영팀의 부담을 줄이고 시스템의 안정성과 확장성을 보장한다.

컨테이너 오케스트레이션 기술은 클러스터 내의 `컨테이너 간의 통신`, `자원 관리`, `상태 모니터링`, `서비스 발견 및 로드 밸런싱` 등을 관리합니다. 이를 통해 애플리케이션은 복잡한 환경에서도 확장 가능하고 안정적으로 실행될 수 있습니다.

<br>

`컨테이너 오케스트레이션 기술은 왜 필요할까?`

<br>

![컨테이너 기술 발전](../images/Container_Evolution.svg)

<br>

우선 모놀리식 아키텍처로 구성되어 있는 어플리케이션이라면 컨테이너 오케스트레이션이 필요없다고 단언할 수 있다.

하지만 마이크로서비스 아키텍처라면 컨테이너 오케스트레이션 기술은 필수라고 할 수 있다. 

모놀리식 아키텍처에서는 하나의 코드베이스로 되어 있기 때문에 하나의 어플리케이션에 대해서만 자원 관리, 상태 모니터링, 로깅, 로드 밸런싱을 해주면 된다. 

하지만 마이크로서비스 아키텍처에서는 하나의 앱 안에 5개의 작은 서비스들로 구성되어 있다고 가정해보자. 각각의 서비스는 DB, UI, Backend 등을 컨테이너로 각각 분리해뒀다. 그럼 벌써 15개의 컨테이너가 생긴다. 

어느 특정 시간대에 트래픽이 몰려서 앱에 성능이 문제가 생겼다고 가정해보자. 그럼 15개의 컨테이너를 돌면서 모니터링하면서 서버에 부하가 가는 것인지, 렌더링이 문제인 것인지, DB 에서 문제가 있는지 파악해야 한다.

컨테이너 오케스트레이션 기술을 사용하면 여러 개로 분할되어 있는 컨테이너의 공통적인 관심사 로깅, 모니터링, 자원 관리를 한 눈에 볼 수 있고, 한 번에 관리할 수 있도록 도와준다. 
또한, A 컨테이너에서 오류가 발생했을 시 새로운 컨테이너를 생성하여 A 컨테이너와 동일한 환경을 구성하여 서비스를 시작하여 장애복구를 구현할 수도 있다.

<br>

`쿠버네티스가 제공하는 기능`
- **서비스 디스커버리와 로드 밸런싱** : 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** : 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다
- **자동화된 롤아웃과 롤백** : 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** : 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** : 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** : 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.

<br>

### API Gateway

---

대표적인 서비스로는 Nginx, Istio 가 있습니다. 

![API Gateway](../images/API%20Gateway.png)

`API Gateway 의 사용 목적`

- **인증과 인가 관리**: API Gateway는 클라이언트 요청을 받아들이고, 요청에 따라 사용자 인증 및 권한 부여를 처리할 수 있습니다. 사용자 인증을 처리하고 요청이 유효한 사용자에 의해 수행되는지 확인하여 보안을 강화할 수 있습니다.
- **로드 밸런싱**: API Gateway는 다수의 백엔드 서비스로의 요청을 분산하기 위해 로드 밸런싱을 수행합니다. 이를 통해 트래픽이 고르게 분배되고, 단일 서비스에 대한 부하를 줄일 수 있습니다.
- **요청 라우팅**: API Gateway는 클라이언트 요청을 백엔드 서비스로 라우팅합니다. 이를 통해 클라이언트는 단일 엔드포인트를 통해 다양한 마이크로서비스에 접근할 수 있습니다.
- **프로토콜 변환**: API Gateway는 클라이언트와 백엔드 서비스 간에 다양한 프로토콜을 변환합니다. 예를 들어, 클라이언트가 HTTP 요청을 보내더라도 백엔드 서비스는 HTTPS를 사용하도록 요청을 변환할 수 있습니다.
- **프로토콜 및 포맷 변환**: API Gateway는 클라이언트 요청과 백엔드 서비스 간에 다양한 프로토콜 및 데이터 형식을 변환합니다. 이를 통해 클라이언트와 서버 간의 호환성을 유지하고, 서비스 간의 통신을 원활하게 합니다.
- **모니터링과 로깅**: API Gateway는 클라이언트 요청 및 응답을 모니터링하고 로깅하여 시스템의 상태를 추적하고 분석할 수 있습니다. 이를 통해 시스템 성능을 개선하고 문제를 해결할 수 있습니다.


### 이벤트 기반 아키텍처

---





## 참고

> [IBM - 마이크로서비스란?](https://www.ibm.com/kr-ko/topics/microservices)
>
> [마이크로서비스 아키텍처 뭣이 중한디?](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/)
> 
> [도커는 왜 사용하는 것일까?](https://mvje.tistory.com/161)
> 
> [쿠버네티스 공식문서 - 쿠버네티란 무엇인가?](https://kubernetes.io/ko/docs/concepts/overview/)
> 
> [요즘 IT - API Gateway 톺아보기(스로틀링과 알고리즘 구현)](https://yozm.wishket.com/magazine/detail/1900/)

