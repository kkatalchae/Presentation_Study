
## 서론

---

앞서 모놀리식, 마이크로서비스 아키텍처의 개념과 차이점에 대해 살펴봤다.

마이크로서비스 아키텍처가 트렌드로 부상함에 따라 마이크로서비스가 무조건 좋다라고 생각하는 관점은 옳지 않다라는 생각이 들었을 것이다.

두 아키텍처 간의 차이점을 명확히 알고 왜 우리 서비스가 마이크로서비스 아키텍처를 채택해야하는지 명확하게 알고 채택하자.

또한, 마이크로서비스 아키텍처의 장점을 100% 활용하기 위해서는 많은 준비가 필요하다는 것을 알게 되었다.

이제는 마이크로서비스 아키텍처를 사용하기 위해 우리 팀은 어떤 기술에 대한 선행학습이 필요한지 알아보자.


## 마이크로서비스를 위해 필요한 기술 스택


### 컨테이너 기술

---

대표적인 서비스는 `Docker` 가 있다.

컨테이너는 가상화 기술을 이용하여 어플리케이션과 개발 경을 격리된 공간에서 실행하는 단위를 말한다.

도커는 이러한 컨테이너를 기반으로 하는 가상화 플랫폼이다. 

Window 운영체제에서 Ubuntu 를 사용하려고 VirtualBox 와 같은 툴을 통해 가상화 방식을 경험해본 이들도 있을 것이다.

하지만 도커의 가상화 기술과 VirtualBox 와 같은 Virtual Machine 은 큰 차이가 존재한다. 

<br>

![도커와 가상머신 차이](../images/가상머신_도커.jpeg)

<br>

가장 결정적인 차이는 가상 머신에 비해 컨테이너 기술이 가볍고 빠르다는 점이다. 

가상 머신은 기존의 컴퓨팅 리소스에 하이퍼바이저라는 것을 통해서 기존 OS 위에서 여러 OS 가 동작할 수 있도록 리소스를 가상화하고 분배합니다.

반면 컨테이너 기술을 기존 컴퓨팅 자원의 운영체제를 커널을 통해 공유함으로서 가볍게 리소스를 가상화하여 격리된 공간으로 분배할 수 있습니다. 


<br>

> **하이퍼바이저란?**
> 
> 하이퍼바이저는 단일 물리적 머신에서 여러 가상 머신을 실행하는 데 사용할 수 있는 소프트웨어입니다. 모든 가상 머신에는 고유한 운영 체제와 애플리케이션이 있습니다. 하이퍼바이저는 필요에 따라 CPU 및 메모리와 같은 기본 물리적 컴퓨팅 리소스를 개별 가상 머신에 할당합니다. 따라서 물리적 IT 인프라의 최적 사용을 지원합니다.
>
> **커널이란?**
> 
> 커널은 운영 체제의 핵심이며, 하드웨어 리소스를 관리하고 프로세스 간의 통신을 조정합니다. 
> 또한 주변 장치와 상호 작용하여 파일 시스템, 메모리 관리, 네트워킹 등과 같은 기능을 제공합니다. 
> 커널은 시스템의 안정성, 보안, 성능에 매우 중요한 역할을 합니다.

<br>

`왜 마이크로서비스에서는 컨테이너 기술이 중요할까?`

- **독립성과 격리**: 컨테이너는 각각의 서비스를 격리된 환경에서 실행시킵니다. 이는 서비스 간의 상호 작용이나 충돌을 방지하고, 개별 서비스의 독립성을 보장합니다.
- **확장성**: 컨테이너는 가벼우며 빠르게 생성되고 제거될 수 있어서 서비스의 확장이 용이합니다. 필요에 따라 서비스 인스턴스를 쉽게 늘리거나 줄일 수 있습니다.
- **유연성**: 컨테이너는 여러 플랫폼에서 실행될 수 있습니다. 개발 환경, 테스트 환경, 프로덕션 환경 등에서 일관되게 동작합니다.
- **자동화와 관리 용이성**: 컨테이너 기술은 배포, 확장, 모니터링, 로깅 등과 같은 운영 작업을 자동화하고 편리하게 관리할 수 있도록 합니다. 이는 시스템을 효율적으로 운영할 수 있게 해줍니다.
- **환경 일관성**: 컨테이너는 패키지화된 소프트웨어와 그 실행 환경을 함께 제공하기 때문에 서비스의 환경 일관성을 유지할 수 있습니다. 이는 배포 과정에서 발생할 수 있는 문제를 줄여줍니다.
- **비용 절감**: 가상화된 컨테이너는 더 적은 자원을 사용하므로 하드웨어 리소스를 효율적으로 활용할 수 있고, 클라우드 환경에서는 비용을 절감할 수 있습니다.

예를 들어, 각각의 개발자의 개인 PC 에 개발 환경을 세팅한다고 가정해보자.

각 개발자가 사용하는 PC 의 운영체제가 다르다면 node, java 를 설치하고 실행하는데 필요한 명령어가 상이하기 때문에 이에 맞게 명령어를 찾아서 실행해줘야 한다.
또한, 어플리케이션에 필요한 메모리와 같은 컴퓨팅 리소스가 변한다면 어플리케이션을 실행하려는 모든 PC 에서 세팅 값을 수정해줘야 한다.

도커를 사용하게 되면 컴퓨팅 리소스에 대한 설정 값, 운영체제, 배포 스크립트와 같은 어플리케이션 실행에 필요한 세팅들을 코드로 작성할 수 있다. 

코드로 작성된 도커 파일을 공유하면 개인의 PC 에서 동일한 세팅이 보장되는 것이다. 이것이 얼마나 아름다운 일인지는 개발 환경을 세팅을 해본 사람이라면 누구나 알 수 있을 것이다. 

### 컨테이너 오케스트레이션 기술

---

대표적인 서비스로는 Google 에서 개발한 Kubernetes 가 있다. 

컨테이너 오케스트레이션은 여러 개의 컨테이너를 자동으로 배포, 관리, 확장하고 조정하는 기술이다. 이는 대규모 분산 애플리케이션을 구축하고 운영하는 데 필요한 작업을 자동화하여 개발자와 운영팀의 부담을 줄이고 시스템의 안정성과 확장성을 보장한다.

컨테이너 오케스트레이션 기술은 클러스터 내의 `컨테이너 간의 통신`, `자원 관리`, `상태 모니터링`, `서비스 발견 및 로드 밸런싱` 등을 관리합니다. 이를 통해 애플리케이션은 복잡한 환경에서도 확장 가능하고 안정적으로 실행될 수 있습니다.

<br>

`컨테이너 오케스트레이션 기술은 왜 필요할까?`

<br>

![컨테이너 기술 발전](../images/Container_Evolution.svg)

![배포 과정 정리](../images/배포과정정리.png)
<br>

우선 모놀리식 아키텍처로 구성되어 있는 어플리케이션이라면 컨테이너 오케스트레이션이 필요없다고 단언할 수 있다.

하지만 마이크로서비스 아키텍처라면 컨테이너 오케스트레이션 기술은 필수라고 할 수 있다. 

모놀리식 아키텍처에서는 하나의 코드베이스로 되어 있기 때문에 하나의 어플리케이션에 대해서만 자원 관리, 상태 모니터링, 로깅, 로드 밸런싱을 해주면 된다. 

하지만 마이크로서비스 아키텍처에서는 하나의 앱 안에 5개의 작은 서비스들로 구성되어 있다고 가정해보자. 각각의 서비스는 DB, UI, Backend 등을 컨테이너로 각각 분리해뒀다. 그럼 벌써 15개의 컨테이너가 생긴다. 

어느 특정 시간대에 트래픽이 몰려서 앱에 성능이 문제가 생겼다고 가정해보자. 그럼 15개의 컨테이너를 돌면서 모니터링하면서 서버에 부하가 가는 것인지, 렌더링이 문제인 것인지, DB 에서 문제가 있는지 파악해야 한다.

컨테이너 오케스트레이션 기술을 사용하면 여러 개로 분할되어 있는 컨테이너의 공통적인 관심사 로깅, 모니터링, 자원 관리를 한 눈에 볼 수 있고, 한 번에 관리할 수 있도록 도와준다. 
또한, A 컨테이너에서 오류가 발생했을 시 새로운 컨테이너를 생성하여 A 컨테이너와 동일한 환경을 구성하여 서비스를 시작하여 장애복구를 구현할 수도 있다.

<br>

`쿠버네티스가 제공하는 기능`
- **서비스 디스커버리와 로드 밸런싱** : 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** : 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다
- **자동화된 롤아웃과 롤백** : 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** : 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** : 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** : 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.

<br>

### API Gateway

---

대표적인 서비스로는 Nginx, Istio 가 있습니다. 

![API Gateway](../images/API%20Gateway.png)

위 그림처럼 클라이언트(프론트엔드) 에서 각각의 마이크로서비스로 요청을 보내는 것도 가능하다. 하지만 보통의 마이크로서비스 아키텍처에서는 API Gateway 를 사용하여 처리한다.

우선 프론트엔드는 각 요청에 맞는 서비스를 알고 있어야 한다. API A, B 가 있다면 해당 요청은 어떤 URI 로 보내야하는지 알고 있어야하며 변경될 때마다 관리가 필요하다. 

또한, 여러 서버에 HTTP 요청을 보내는 것은 각각의 서버와 통신하기 위한 과정이 발생하기 때문에 한 개의 API Gateway 를 통해서 통신하는 것보다 응답속도가 느려진다.

마이크로서비스 아키텍처는 각각의 서비스에 맞게 DB나 프로토콜, 기술을 유연하게 구성할 수 있다. 그렇다보니 모든 마이크로서비스가 웹 통신에 적합한 프로토콜을 채택하고 있지는 않다. 

때문에 API Gateway 를 이용해서 각 서비스에서 받은 응답을 웹 통신에 적합한 데이터로 가공하여 통신할 수 있다. 

`API Gateway 의 사용 목적`

- **인증과 인가 관리**: API Gateway는 클라이언트 요청을 받아들이고, 요청에 따라 사용자 인증 및 권한 부여를 처리할 수 있습니다. 사용자 인증을 처리하고 요청이 유효한 사용자에 의해 수행되는지 확인하여 보안을 강화할 수 있습니다.
- **로드 밸런싱**: API Gateway는 다수의 백엔드 서비스로의 요청을 분산하기 위해 로드 밸런싱을 수행합니다. 이를 통해 트래픽이 고르게 분배되고, 단일 서비스에 대한 부하를 줄일 수 있습니다.
- **요청 라우팅**: API Gateway는 클라이언트 요청을 백엔드 서비스로 라우팅합니다. 이를 통해 클라이언트는 단일 엔드포인트를 통해 다양한 마이크로서비스에 접근할 수 있습니다.
- **프로토콜 변환**: API Gateway는 클라이언트와 백엔드 서비스 간에 다양한 프로토콜을 변환합니다. 예를 들어, 클라이언트가 HTTP 요청을 보내더라도 백엔드 서비스는 HTTPS를 사용하도록 요청을 변환할 수 있습니다.
- **프로토콜 및 포맷 변환**: API Gateway는 클라이언트 요청과 백엔드 서비스 간에 다양한 프로토콜 및 데이터 형식을 변환합니다. 이를 통해 클라이언트와 서버 간의 호환성을 유지하고, 서비스 간의 통신을 원활하게 합니다.
- **모니터링과 로깅**: API Gateway는 클라이언트 요청 및 응답을 모니터링하고 로깅하여 시스템의 상태를 추적하고 분석할 수 있습니다. 이를 통해 시스템 성능을 개선하고 문제를 해결할 수 있습니다.

API Gateway 를 사용하면서 얻을 수 있는 가장 큰 이익은 시스템 내부의 아키텍처를 숨길 수 있다는 점이다. 

단점으로는 구현해야 관리해야하는 포인트가 하나가 더 늘어난다는 점, API Gateway 가 성능상의 병목 지점이 될 수 있다는 점이다. 

이러한 단점으로 인해 API Gateway 를 비동기적이고, non-blocking I/O 처리가 가능하도록 구현하는 것이 적은 비용으로 최대의 성능을 발휘할 수 있는 관건이다.

`API Gateway 를 구현할 때 고려해야 할 점`

- **보안** : API Gateway는 클라이언트와 백엔드 서비스 간의 보안을 강화해야 합니다. 인증, 인가, 데이터 마스킹 등의 보안 기능을 제공해야 하며, 보안 정책을 엄격하게 관리해야 합니다.
- **성능** : API Gateway는 클라이언트 요청을 효율적으로 처리해야 합니다. 성능이 중요한 요청은 빠르게 응답해야 하며, 대규모 트래픽을 처리할 수 있어야 합니다.

> API Gateway 는 요청이 몰리는 지점이기 때문에 동일한 요청에 대해 매번 마이크로서비스에 요청을 보내는 것이 아니라 캐싱을 통해 기존 결과를 재활용할 수 있도록 설계하는 것이 중요하다.

- **확장성** : API Gateway는 서비스 확장에 대비해야 합니다. 확장 가능한 아키텍처를 가지고 있어서 시스템이 성장할 때 쉽게 확장할 수 있어야 합니다.
- **모니터링 및 분석** : API Gateway는 클라이언트 요청 및 응답을 모니터링하고 로깅하여 시스템의 상태를 추적하고 분석할 수 있어야 합니다. 이를 통해 시스템 성능을 개선하고 문제를 해결할 수 있습니다.
- **유연성** : API Gateway는 다양한 요구 사항을 수용할 수 있어야 합니다. 다양한 프로토콜을 지원하고, 요청 및 응답의 변환을 처리할 수 있어야 합니다.

### 이벤트 기반 아키텍처

---

`개념`

시스템의 구성 요소들이 상호 작용할 때 발생하는 이벤트에 기반하여 동작하는 소프트웨어 아키텍처 패턴
이벤트 주도 아키텍처는 이벤트의 발생, 전파, 처리를 중심으로 설계되어 있으며, 이벤트가 중심이 되는 비동기적인 통신 방식을 사용합니다.

이벤트 주도 아키텍처에서는 시스템의 구성 요소들이 서로 독립적으로 작동하며, 각각의 구성 요소는 자신이 관심을 갖는 이벤트를 발행하거나 구독하여 상호 작용합니다.

`MSA 는 왜 이벤트 주도 아키텍처를 사용하는가?`

모놀리식 아키텍처에서는 하나의 어플리케이션과 하나의 데이터베이스를 사용하기 때문에 데이터베이스의 트랜잭션을 보장하고 관리하기 용이하다.

하지만 MSA 에서는 각각의 데이터베이스가 독립되어 있기 때문에 트랜잭션을 보장하고 관리하기 어렵다.

![분산된 데이터베이스에서의 트랜잭션 관리 이슈](../images/분산데이터베이스_트랜잭션_관리이슈.png)

쿠팡과 같은 쇼핑 시스템을 예를 들어보자. 내부적으로 주문 서비스가 있고 결제 서비스가 있을 때 기본적으로 결제와 주문이 생성되는 것은 하나의 트랜잭션으로 동작해야 한다.

하지만 서비스가 나눠져 있기 때문에 결제에서는 문제가 없었기 때문에 결제 레코드가 생겼지만 주문 서비스에서 문제가 발생하여 주문은 정상적으로 생성되지 않았다. 그럼 결제도 같이 취소가 되어야 하지만 결제 서비스에서는 주문이 정상적으로 생성되지 않았다는 사실을 알 수 없다.

이러한 문제를 전통적으로는 2단계 커밋을 통해서 해결한다.

> **2단계 커밋**
> 분산된 트랜잭션의 원자성을 보장하기 위해서 고안된 프로토콜의 구현체
> 코디네이터 서버를 두어 각각의 서버와 통신하여 데이터를 커밋할 지 롤백할 지 관리하는 방법

하지만 NoSQL 을 포함한 대부분의 최근 기술들이 2단계 커밋을 지원하지 않는다. 

이러한 트랜잭션을 보장하기 위해 이벤트 주도 아키텍처를 사용한다.

이벤트 주도 아키텍처를 통해서 트랜잭션의 원자성을 보장하는 방법은 여러가지가 있다.

- **이벤트 소싱(Event Sourcing)** : 이벤트 소싱은 모든 시스템 상태 변화를 이벤트의 시퀀스로 저장하는 패턴입니다. 각각의 상태 변화는 이벤트로 기록되고, 이벤트 로그를 통해 상태를 재구성할 수 있습니다. 이벤트 소싱을 사용하면 트랜잭션의 상태를 복제하거나 롤백할 수 있으며, 분산된 데이터베이스 간의 일관성을 유지할 수 있습니다.
- **분산 트랜잭션 관리** : 이벤트 주도 아키텍처에서는 다양한 서비스 간의 통신이 비동기적으로 이루어집니다. 이를 위해 분산 트랜잭션 관리 프레임워크를 사용하여 여러 개의 이벤트에 대한 트랜잭션을 관리할 수 있습니다. 예를 들어, 이벤트의 발행과 처리를 트랜잭션 단위로 묶어서 원자성을 보장할 수 있습니다.
- **컴펜세이팅 트랜잭션(Compensating Transaction)** : 이벤트 주도 아키텍처에서는 오류 처리와 회복 메커니즘이 중요합니다. 분산된 데이터베이스에서 트랜잭션의 원자성을 보장하기 위해 컴펜세이팅 트랜잭션을 사용할 수 있습니다. 이는 트랜잭션의 롤백 과정을 수행하는 트랜잭션입니다. 예를 들어, 오류가 발생했을 때 이전에 수행한 작업을 취소하거나 보상하는 작업을 수행할 수 있습니다.
- **분산 락(Distributed Lock)** : 분산된 데이터베이스에서는 여러 서비스가 동시에 데이터에 접근할 수 있기 때문에 동시성 문제가 발생할 수 있습니다. 이를 해결하기 위해 분산 락을 사용하여 특정 데이터에 대한 접근을 동기화할 수 있습니다. 이를 통해 여러 서비스 간의 트랜잭션을 조율하고 일관성을 유지할 수 있습니다.

![이벤트 주도 아키텍처](../images/event-driven-architecture.svg)

MSA 에서 가장 중요한 부분은 각 서비스의 결합을 얼마나 잘 줄일 수 있냐는 점입니다. 

예를 들었던 쇼핑을 보면 클라이언트가 주문을 하고 결제가 있고 결제가 완료되면 주문을 생성하는 선후 관계가 존재합니다.

결제가 완료되면 주문 서비스에 주문을 생성하라는 메시지를 발행하는 것은 논리적인 의존관계가 남아있기 때문에 결합이 느슨해졌다고 볼 수 없다.

각 이벤트 간의 상관관계에 대해 각 서비스는 모르고 내부 비즈니스 로직의 변경에 영향을 받지 않을 때 느슨한 결합이 이뤄졌다고 보는게 맞습니다.

이렇게 이벤트 기반 아키텍처를 통해 느슨한 결합을 이뤄냈다면 이벤트를 구독하고 있는 각 서비스에서는 이벤트에 대한 해당 서비스에서의 로직만 신경쓰면 된다.

## 참고

> [IBM - 마이크로서비스란?](https://www.ibm.com/kr-ko/topics/microservices)
>
> [마이크로서비스 아키텍처 뭣이 중한디?](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/)
> 
> [도커는 왜 사용하는 것일까?](https://mvje.tistory.com/161)
> 
> [쿠버네티스 공식문서 - 쿠버네티란 무엇인가?](https://kubernetes.io/ko/docs/concepts/overview/)
> 
> [요즘 IT - API Gateway 톺아보기(스로틀링과 알고리즘 구현)](https://yozm.wishket.com/magazine/detail/1900/)
> 
> [우아한 기술블로그 - 회원시스템 이벤트기반 아키텍처 구축하기](https://techblog.woowahan.com/7835/)
> 
> [AWS - 이벤트 기반 아키텍처란?](https://aws.amazon.com/ko/what-is/eda/)

